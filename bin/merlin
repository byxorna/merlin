#!/usr/bin/env ruby

$:.unshift File.join File.dirname(__FILE__), *%w[.. lib]
require 'merlin'
require 'etcd'
require 'optparse'
require 'yaml'
require 'logger'

@options = {}
@defaults = {
  :mode => :watch,
  :config => '/etc/merlin/default.yaml',
  :debug => false,
  :daemonize => false,
  :etcd_server => 'localhost',
  :etcd_port => 4001,
  :file_watch => true
}

OptionParser.new do |opts|
  opts.on('-h','--help','Show help') { puts opts ; exit 0 }
  opts.on('-o','--oneshot','Run a single generation; dont watch for changes') {@options[:mode] = :oneshot}
  opts.on('-c','--config CONFIG',String,"Use templates config (Default: #{@defaults[:config]})"){|v| @options[:config] = v}
  # TODO implement --debug
  #opts.on('-d','--debug','Enable debugging'){ @options[:debug] = true}
  # TODO implement me
  #opts.on('-D','--daemonize','Daemonize process'){ @options[:daemonize] = true}
  opts.on('-e','--etcd SERVER[:PORT]',String,"Etcd server and optional port (Default #{@defaults[:etcd_server]}:#{@defaults[:etcd_port]})") do |v|
    host,port = v.split ':'
    @options[:etcd_server] = host
    @options[:etcd_port] = port unless port.nil?
  end
  opts.on('--[no-]filewatch',"Watch files on disk for changes while watching (Default: #{@defaults[:file_watch]})"){|v| @options[:file_watch] = v}
end.parse!

@options = @defaults.merge @options

begin
  @config = YAML.load_file @options[:config]
rescue => e
  abort "Unable to parse config #{@options[:config]}! #{e.message}"
end

# vet config is all present
default_config = {
  'statics' => [],
  'atomic' => false
}
# TODO add more logic about ensuring config is well formed
targets = @config.inject({}) do |memo,(k,v)|
  memo[k.to_sym] = default_config.merge v
  ['watch','templates','destination'].each do |config_setting|
    abort "Template #{k} is missing #{config_setting}!" if memo[k.to_sym][config_setting].nil?
  end
  memo
end

#TODO implement me to log to a file?
logger = Logger.new STDOUT

if @options[:mode] == :watch
  #TODO this should spawn a bunch of threads to watch?
  watchers = targets.inject({}) do |memo, (name, config)|
    logger.info "Starting up emitter for #{name}"
    emitter = Merlin::Emitter.new(name, config['templates'], config['destination'],
      :check_cmd => config['check_cmd'],
      :commit_cmd => config['commit_cmd'],
      :statics => config['statics'],
      :atomic => config['atomic'],
      :logger => logger)
    # TODO figure out if the Etcd::Client is thread safe, or if we need a separate instace per emitter/watcher pair
    begin
      client = Etcd::Client.new(:host => @options[:etcd_server], :port => @options[:etcd_port])
    rescue => e
      abort "Unable to configure etcd client: #{e.message}"
    end
    watcher = Merlin::EtcdWatcher.new(client, config['watch'], :logger => logger)
    # this way we will trigger a watch immediately on startup
    emit_blk = proc do |arg|
      begin
        watcher.get do |data|
          begin
            emitter.emit data
          rescue => e
            # just log and carry on. we dont wanna kill the watcher thread if a templating error happened
            logger.error "Error emitting configurations: #{e.message}"
            logger.error e.backtrace.join("\n")
          end
        end
      rescue => e
        logger.error "Error getting data from etcd at #{config['watch']}: #{e.message}"
        logger.error e.backtrace.join("\n")
      end
    end

    file_watchers = []
    if @options[:file_watch]
      file_watchers = (config['statics'].keys + config['templates'].keys).map do |f|
        Merlin::FileWatcher.new(f, logger).observe(&emit_blk)
      end
    end

    logger.debug "Determining latest etcd index to observe from"
    d = watcher.get
    watcher.observe d.etcd_index, &emit_blk

    memo[name] = {
      :emit_blk => emit_blk,
      :etcd => watcher,
      :files => file_watchers
    }
    memo
  end
  Kernel.at_exit do
    watchers.each do |name,refs|
      logger.debug "Terminating watchers for #{name}"
      refs[:etcd].terminate
      refs[:files].each(&:stop)
    end
  end

  # ghetto event loop, just for handling signals (for now)
  # TODO maybe replace with event machine?
  events = []
  trap :USR1 do
    events << :USR1
  end
  trap :HUP do
    events << :HUP
  end
  loop do
    while !events.empty?
      e = events.shift
      if [:HUP, :USR1].include? e
        logger.warn "Received reload request"
        watchers.each {|target,refs| refs[:emit_blk].call}
      else
        logger.warn "Received unknown event #{e}; ignoring"
      end
    end
    sleep 0.1
  end
else
  targets.each do |name, config|
    emitter = Merlin::Emitter.new(name, config['templates'], config['destination'],
      :check_cmd => config['check_cmd'],
      :commit_cmd => config['commit_cmd'],
      :statics => config['statics'],
      :atomic => config['atomic'],
      :logger => logger)
    begin
      client = Etcd::Client.new(:host => @options[:etcd_server], :port => @options[:etcd_port])
    rescue => e
      abort "Unable to configure etcd client: #{e.message}"
    end
    watcher = Merlin::EtcdWatcher.new(client, config['watch'], :logger => logger)
    emitter.emit watcher.get
  end
end
